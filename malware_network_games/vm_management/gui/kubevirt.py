from sqlite3 import connect
import subprocess
from kubernetes import client, config
from collections import defaultdict
import re
from typing import List, Dict, Tuple, Optional, Set
import json
import os
import cachetools.func

config.load_kube_config() 
v1 = client.CoreV1Api()
d = v1.list_node()
with open('benign_domains.txt', 'r') as f:
    benign_domains = f.read().splitlines()
suffixes = [
    ".gatech.edu",
    ".cluster.local",
    ".prod.do.dsp.mp.microsoft.com",
    ".download.windowsupdate.com",
    "smartscreen-prod.microsoft.com",
    ".microsoft.com",
    "digicert.com", 
    "publicsuffix.org",
    ".msedge.net",
]

FORCE_NODE_REFRESH = True
POD_DETAILS = defaultdict(dict)

def filter_local_domains(domains:List[Dict[str, str]]) -> List[Dict[str,str]]:
    def is_local(entry:Dict[str, str]) -> bool:
        domain = entry['domain']
        local_domain_suffixes = ['.gatech.edu', '.cluster.local'] 
        for s in local_domain_suffixes:
            if domain.endswith(s):
                return False
        return True
        
    return list(filter(is_local, domains))

def filter_benign_domains(domains: List[Dict[str, str]]) -> List[Dict[str, str]]:
    def is_malicious(entry:Dict[str, str]) -> bool:
        domain = entry['domain']
        if domain in benign_domains:
            return False
        for s in suffixes:
            if domain.endswith(s):
                return False
        return True
        
    return list(filter(is_malicious, domains))


def create_vm(name:str, sample_path:str, start_paused=False, start_with_monitor=False, timeout=None):
    command = ["../create_malware_vm.sh",  "-s", sample_path, "-i", name]
    if timeout is not None:
        command.extend(["-t", timeout])
    if start_paused:
        command.append(" -p ")
    if start_with_monitor:
        command.append(" -r ")
    
    rc = subprocess.call(command)
    return rc

def create_monitor(target_vm: str):
    command = ["../create_monitor.sh",  target_vm]
    rc = subprocess.call(command)
    return rc

def create_mitm(mitm_pod_name: str, vm_pod_name: str, dga_fake_c2=None):
    if dga_fake_c2 is not None:
        mitm_pod_name = "c2-" + mitm_pod_name
    else:
        mitm_pod_name = "mitm-" + mitm_pod_name

    script_directory_path = "v-mitm-test/scripts"
    command = ["/home/thomas/v-mitm-test/pod_spawn.sh", mitm_pod_name, vm_pod_name, script_directory_path]
    if dga_fake_c2 is not None:
        command.append(dga_fake_c2)
    rc = subprocess.call(command)
    return rc

def connect_monitor_to_vm(vm_pod_name:str, monitor_pod_name: str):
    script_path = "/home/kevinv/PRINCIPALS/gt/vm_management/redirect_traffic.sh"
    command = [script_path, vm_pod_name, monitor_pod_name]
    rc = subprocess.call(command)
    return rc

def update_traffic() -> Dict:
    # Iterate over the monitors and MITMs and update their traffic
    nodes = get_nodes(force_update=False)
    results = defaultdict(list)
    for node in nodes['mitm'] + nodes['monitor']:
        if not is_auto_quarantine_set(node['pod_name']):
            continue
        # copy_traffic_file(node['pod_name']) # TODO: May need to do a temporary file and swap to minimize the time that the file is being written in case reads fail.
        # If this is an auto quarantine node, also check the domains.
        malicious_domains = pull_domains(node['pod_name'], filter_benign=True)
        if malicious_domains is not None:
            results[node['pod_name']] = malicious_domains
    return results

def _get_traffic_file(target):
    if target.endswith("-monitor"):
        identifier = target[:-len("-monitor")]
        return  f"malware_{identifier}.pcap"
    elif target.startswith("mitm-"):
        return f"malware_{target}.pcap"
    else:
        raise Exception(f"Trying to pull traffic of unknown target type {target}")


def copy_traffic_file(target: str, wait=False) -> subprocess.Popen:
    target_file = _get_traffic_file(target)
    if target.endswith("-monitor"):
        identifier = target[:-len("-monitor")]
        command = ["kubectl",  "cp", f"default/{target}:/malware_{identifier}.pcap", target_file+".tmp"]
    elif target.startswith("mitm-"):
        command = ["kubectl",  "cp", f"default/{target}:/malware.pcap", target_file + ".tmp"]
    else:
        raise Exception(f"Trying to pull traffic of unknown target type {target}")

    return subprocess.Popen(" ".join(command + [f"; mv {target_file}.tmp {target_file}"]), shell=True)

def _get_ip_filter(target:str) -> Optional[str]:
    # Get the IP addresses of the connected nodes.
    # Get connections between nodes
    connections = get_connection_graph(force_update=False)
    # Find all vms connected to this monitoring node
    connected_vm_pods = [vm for vm, monitors in connections.items() if target in monitors]
  
    interfaces = _get_antrea_podinterfaces()
    connected_ips = [i['ip'] for i in interfaces if i['name'] in connected_vm_pods]
    if len(connected_ips) == 0:
        print(f"No connected ips to pod '{target}'")
        return None
    filter = " or ".join([f"ip.addr == {ip}" for ip in connected_ips])
    return filter

def pull_raw(target: str) -> Optional[str]:
    if not target.startswith('mitm') and not is_traffic_monitoring_set(target):
        return None

    target_file = _get_traffic_file(target)
    if target_file is None:
        return None

    filter_name = _get_ip_filter(target)
    if filter_name is None:
        return None
    command = f"tshark -nr {target_file} -Y".split() + [f"{filter_name}"]
    try:
        dev_null = open(os.devnull, 'w')
        results = subprocess.check_output(command, stderr=dev_null).decode()
    except subprocess.CalledProcessError as e: 
        # Even if the file claims to be cut short, we can get output from the 
        # exception
        results = e.output.decode()
    results = '\n'.join(results.split('\n')[-1000:])
    return results

def pull_malicious_domains(target: str) -> Optional[List[Dict[str, str]]]:
    return _pull_domains(target, filter_benign=True) # Used for checking if auto-quarantine should be done.

def pull_domains(target: str, filter_benign=False) -> Optional[List[Dict[str, str]]]:
    if not target.startswith('mitm') and not is_traffic_monitoring_set(target):
        return None
    return _pull_domains(target, filter_benign)

def _pull_domains(target: str, filter_benign=False) -> Optional[List[Dict[str, str]]]:
    # import time
    # start = time.time()
    target_file = _get_traffic_file(target)
    if target_file is None:
        return None
    # An optimization, check the size of the file before and after the copy,
    # if it is the same, assume that it has not changed, and return the cached data
    try:
        filesize = os.path.getsize(target_file)
    except FileNotFoundError:
        return None
    # TODO: This function can take half a second, it might make sense to only
    # do this if the output of the file has changed. However, there is a bit of
    # a challenge given that we have two different types of traffic that are
    # parsed from the file (raw and non) This will only really help with no-op 
    # updates and swapping between different views     
    filter_name = _get_ip_filter(target)
    if filter_name is None:
        return None
    command = f"tshark -nr {target_file}  -T fields -e dns.qry.name -e ip.src -Y".split() + [f"({filter_name}) and dns.flags.response==0"]
    try:
        dev_null = open(os.devnull, 'w')
        results = subprocess.check_output(command, stderr=dev_null).decode()
    except subprocess.CalledProcessError as e: 
        # Even if the file claims to be cut short, we can get output from the 
        # exception
        results = e.output.decode()

    unique_domains = filter(None, set(results.split('\n')))
    results = [{"domain": domain.split()[0], "src_ip": domain.split()[1]} for domain in sorted(unique_domains)]
    
    if results is None:
        return None

    if filter_benign:
        results = filter_benign_domains(results)
    else:
        results = filter_local_domains(results)

    results = sorted(results, key=lambda x: x['domain'])
    return results


def is_auto_quarantine_set(pod_name: str) -> bool:
    return POD_DETAILS[pod_name].get("auto_quarantine_enabled", False)

def is_traffic_monitoring_set(pod_name: str) -> bool:
    return POD_DETAILS[pod_name].get("traffic_monitoring_enabled", False)

def set_pod_details(pod_name: str, settings: Dict) -> None:
    for k, v in settings.items():
        POD_DETAILS[pod_name][k] = v

def get_pod_details(pod_name:str) -> Dict[str, str]:
    for pod in v1.list_namespaced_pod("default").items:
        if pod.metadata.name == pod_name:
            break
    else:
        raise Exception(f"Unable to find pod details for pod {pod_name}")

    pod_details = POD_DETAILS.get(pod_name, {})

    return {
        "pod_name": pod.metadata.name,
        "ip": pod.status.pod_ip,
        **pod_details,
    }

def refresh_nodes() -> Dict[str, List]:
    if FORCE_NODE_REFRESH:
        FORCE_NODE_REFRESH=False
        return get_nodes(force_update=True)
    return {}

def get_nodes(force_update=True) -> Dict[str, List]:
    if force_update:
        _get_antrea_flows.cache_clear()
        _get_antrea_podinterfaces.cache_clear()

    pods = v1.list_namespaced_pod("default")
    results = defaultdict(list)
    for pod in pods.items:
        if pod.metadata.name.endswith('-monitor'):
            results['monitor'].append({
                "pod_name": pod.metadata.name,
                "label_name": pod.metadata.name[:-len('-monitor')]})
        elif pod.metadata.name.startswith('mitm-'):
            results['mitm'].append({
                'pod_name': pod.metadata.name,
                "label_name": pod.metadata.name[len('mitm-'):]
                })
        elif pod.metadata.name.startswith('c2-'):
            results['c2'].append({'pod_name': pod.metadata.name})
        elif pod.metadata.labels is not None:
            name = pod.metadata.labels.get("kubevirt.io/domain", "")
            if name.startswith("win10vm"):
                results['vm'].append({
                    "pod_name": pod.metadata.name,
                    "vm_name": name[len("win10vm-"):],
                    "connections": get_connections(pod.metadata.name),
                })


    return results

def get_connection_graph(force_update:bool=False) -> Dict[str, List[str]]:
    if force_update:
        _get_antrea_flows.cache_clear()
        _get_antrea_podinterfaces.cache_clear()

    connections = {}
    for i in _get_antrea_podinterfaces():
        pod_name = i['name']
        connections[pod_name] = get_connections(pod_name, force_update=False)
    return connections

def get_connections(pod_name: str, force_update=False) -> List[str]:
    """Returns the pods that are connected to this pod"""
    # First, we need to find the flows that correspond to each node
    # Then, we need to check the actions of the node to see which are being redirected
    # Then we need to see where they are being redirected to

    if force_update:
        _get_antrea_flows.cache_clear()
        _get_antrea_podinterfaces.cache_clear()

    interface = _get_matching_interface('name', pod_name)
    connected_interfaces = _get_connected_interfaces(interface)
    connected_pods = [_get_matching_interface("interface-name", i)['name'] for i in connected_interfaces]
    return connected_pods

def _get_actions(line: str) -> List[str]:
    chunks = line.split('actions=')
    assert(len(chunks) == 2)
    return chunks[1].split(',')

def _get_matching_interface(field_name: str, field_value: str) -> Dict[str, str]:
    for i in _get_antrea_podinterfaces():
        if i[field_name] == field_value:
            return i
    raise Exception(f"Could not find matching interface for field '{field_name}' with value '{field_value}'")


def _get_connected_interfaces(pod_interface: Dict[str, str]) -> List[str]:
    """Gets all the interfaces that are connected through this one"""
    # For each flow, look at the actions, and see if there is an output
    pod_interface_name = pod_interface['interface-name']
    connected_interfaces = []
    for flow in _get_antrea_flows():
        # Check that this flow corresponds to this pod. Right now, just checking out flow
        if f"in_port=\"{pod_interface_name}\"" not in flow:
            continue
        actions = _get_actions(flow)
        matches = [re.match("output:\"(.*)\"", a) for a in actions]
        matched_strings = [m.group(1) for m in matches if m is not None]
        connected_interfaces.extend(matched_strings)
    return connected_interfaces



@cachetools.func.lru_cache(maxsize=1)
def _get_antrea_flows() -> List[str]:
    output = subprocess.check_output("kubectl -n kube-system exec -it antrea-agent-h5slq -c antrea-agent -- ovs-ofctl dump-flows br-int".split())
    results =  [line.decode() for line in output.splitlines()]
    return results

@cachetools.func.lru_cache(maxsize=1)
def _get_antrea_podinterfaces() -> List[Dict[str, str]]:
    output = subprocess.check_output("kubectl -n kube-system exec -it antrea-agent-h5slq -c antrea-agent -- antctl get podinterface".split())
    columns = "namespace name interface-name ip mac port-uuid of-port container-id".split()

    results = []
    for line in output.splitlines():
        interface_data = {k:v for k,v in zip(columns, line.decode().split())}
        if interface_data['namespace'] != "default":
            continue
        results.append(interface_data)
    return results

def get_matching_nodes(name: str):
    pods = v1.list_namespaced_pod("default")
    matching_nodes = [p.metadata.name for p in pods.items if name in p.metadata.name]
    return matching_nodes

def quarantine(monitor_pod: str, malicious_ips: Set[str]):
    # We need to create a mitm for each of the malicious ips.
    _get_antrea_podinterfaces.cache_clear()
    for ip in malicious_ips:
        vm_pod_name = _get_matching_interface('ip', ip)['name']

        # VM pod names are of the form "virt-launcher-win10vm-(???????)-fjkvw"
        mitm_name = "quarantine-" + '-'.join(vm_pod_name.split('-')[3:-1])
        create_mitm(mitm_name, vm_pod_name)
    FORCE_NODE_REFRESH=True


def delete_node(name: str, category: str):
    if category == 'mitm':
        v1.delete_namespaced_pod(name, "default")
        os.remove(f"{name}.yaml")
    elif category ==  'monitor':
        v1.delete_namespaced_pod(name, "default")
    elif category ==  'c2':
        v1.delete_namespaced_pod(name, "default")
        os.remove(f"{name}.yaml")
    elif category == 'vm':
        filename = f"vm-{name}.yaml"
        command = f"kubectl delete -f {filename}".split()
        rc = subprocess.call(command)
        if rc == 0:
            os.remove(filename)
        else:
            raise Exception(f"Unable to delete VM '{name}'")        
    else:
        raise Exception(f"Unknown node {name} of category {category}")
    # try:
    # except kubernetes.client.exceptions.ApiException as e:
    #     print(e)

    print(f"deleted node {name}")
    # TODO: Need to cleanup the files that are created