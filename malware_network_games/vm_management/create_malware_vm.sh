#!/bin/bash

# Overview
# This script creates a VM via kubevirt that runs the given malware.
# There will be a label for the VM/VMI/pod: kubevirt.io/domain=win10vm-$IDENTIFIER
# To find the pod, use `kubectl get pods -l kubevirt.io/domain=win10vm-$IDENTIFIER`

## Design
# Every time you want to run a vm with some malware, we will create a new VM, and a new malware disk volume.
# We can do this by creating the vm with a random name to prevent collisions.
#
# It is assumed that there is a script present in the VM that will run all files that are present in the
# cd rom that is attached.
# 
## Alternate Design considerations 
# The only way I was able to get a file to be on a disk that a kubevirt VM could access was through uploading it to a datavolume.
# If you are able to find a way to mount local directories so that windows machines can view them, that would be great.
# Alternatively

# Another issue is the manual replication. One idea is if you can send specific commands to a vm on startup (some kind of startup script similar to https://kubevirt.io/user-guide/virtual_machines/startup_scripts/),
# then you could have all malware on a single Read only disk that all vms could read off of. You may run into issues with refershing the disk and whatnot, so don't know if you can overcome that.

set -e

if [[ $# -eq 0 ]]; then
    echo "Usage: $0 -s <sample_path> [-t <timelimit>] [-i <identifier>] [-v <vm-iso-pvc>] [-r <monitor-pod>]"
    echo "  Default identifier is a uuid"
    echo "  Not specifying a timelimit leaves unlimited time for the run"
    exit 1
fi

if ! pgrep -f "kubectl port-forward" ; then
  echo "Need to run port forwarding for data upload. Please run the following command in a separate terminal:"
  echo "   kubectl port-forward -n cdi service/cdi-uploadproxy 8443:443"
  exit 1
fi
VM_ISO_PVC="upload-datavolume"

# File Arguments
SAMPLE_PATH=""
IDENTIFIER=""
RUN_TIME="" 
PAUSE=""
REDIRECT=""
BLOCKFILE=""

while [[ $# -gt 0 ]]; do
  key="$1"

  case $key in
    -s|--sample)
      SAMPLE_PATH="$2"
      shift # past argument
      shift # past value
      ;;
    -t|--time)
      RUN_TIME="$2"
      shift # past argument
      shift # past value
      ;;
    -i|--identifier)
      IDENTIFIER="$2"
      shift # past argument
      shift # past value
      ;;
    -p|--pause)
      PAUSE="Paused"
      shift # past argument
      ;;
    -r|--redirect)
      PAUSE="Paused"
      REDIRECT="Yes"
      shift # past argument
      ;;
    -b|--blockfile)
      PAUSE="Paused"
      BLOCKFILE="$2"
      shift # past argument
      shift # past value
      ;;
    -v|--vm) # Use this to specify the base vm that you want to copy from.
      VM_ISO_PVC="$2"
      shift # past argument
      shift # past value
      ;;
    *)    # unknown option
      echo "Unknown option \"$1\""
      exit 1
  esac
done


if [[ -v $SAMPLE_PATH ]]; then
    echo "--sample flag is required to run."
    exit 1
fi
if ! [[ -f $SAMPLE_PATH ]]; then
    echo "There is no sample file located at \"$SAMPLE_PATH\""
    exit 1
fi

if [[ -z $IDENTIFIER ]]; then
  IDENTIFIER=$(uuidgen)
  echo " * Generated identifier: \'$IDENTIFIER\'"
fi

FILENAME=vm-$IDENTIFIER.yaml

if [ -f $FILENAME ]; then
    echo "$FILENAME already exists."
    exit 1
fi


echo " * Creating malware iso file"
# Create iso file
mkdir malware_folder-$IDENTIFIER
cp $SAMPLE_PATH malware_folder-$IDENTIFIER
mkisofs -o malware-$IDENTIFIER.iso malware_folder-$IDENTIFIER
# Clean up folder without rm -rf
rm malware_folder-$IDENTIFIER/$(basename $SAMPLE_PATH)
rmdir malware_folder-$IDENTIFIER

echo "apiVersion: cdi.kubevirt.io/v1beta1
kind: DataVolume
metadata:
  name: malware-dv-$IDENTIFIER
spec:
  source:
      upload: {}
  pvc:
    accessModes:
      - ReadWriteOnce
    resources:
      requests:
        storage: 1Gi
---
apiVersion: kubevirt.io/v1alpha3
kind: VirtualMachine
metadata:
  name: win10vm-$IDENTIFIER
spec:
  running: false
  template:
    metadata:
      labels:
        kubevirt.io/domain: win10vm-$IDENTIFIER
    spec:
      startStrategy: $PAUSE
      domain:
        cpu:
          cores: 5
        resources:
          requests:
            memory: 10G
        machine:
          type: pc-q35-rhel8.2.0
        devices:
          interfaces:
          - masquerade: {}
            name: default
          disks:
            - disk: {}
              name: win10vm-hd
            - cdrom:
                readonly: false
                bus: sata
              name: malware-dv
      networks:
      - name: default
        pod: {}
      volumes:
        - name: win10vm-hd
          ephemeral:
            persistentVolumeClaim:
              claimName: $VM_ISO_PVC
        - name: malware-dv
          dataVolume:
             name: malware-dv-$IDENTIFIER" > $FILENAME

# Create the resources we just specified
kubectl create -f $FILENAME
sleep 2
# upload data to the datavolume
virtctl image-upload dv malware-dv-$IDENTIFIER --insecure  --image-path=malware-$IDENTIFIER.iso --uploadproxy-url=https://localhost:8443
sleep 2
# Cleanup data being uploaded
rm malware-$IDENTIFIER.iso

# start the vm
virtctl start win10vm-$IDENTIFIER

if [[ ! -z $PAUSE ]]; then
  kubectl wait --for=condition=paused vm win10vm-$IDENTIFIER --timeout=30s
else
  kubectl wait --for=condition=ready vm win10vm-$IDENTIFIER --timeout=30s
fi

if [[ ! -z $REDIRECT ]]; then

  # Create and redirect traffic to the monitor
  script_full_path=$(dirname "$0")
  $script_full_path/create_monitor.sh $IDENTIFIER
  MONITOR_CONTAINER=$IDENTIFIER-monitor

  virtctl unpause vm win10vm-$IDENTIFIER

  if [[ ! -z $RUN_TIME ]]; then
    echo "  * Waiting for $RUN_TIME seconds"
    sleep $RUN_TIME
    kubectl cp default/$MONITOR_CONTAINER:/malware_$IDENTIFIER.pcap malware_$IDENTIFIER.pcap
    kubectl delete pod $MONITOR_CONTAINER
    rm $MONITOR_CONTAINER.yaml
  fi
elif [[ ! -z $BLOCKFILE ]]; then
  # Allow blockfile to be accessed by the MITM
  cp $BLOCKFILE /home/thomas/v-mitm-test/scripts/blockfile
  # pull up the mitm
  VM_NAME=win10vm-$IDENTIFIER
  MITM_CONTAINER=mitm-$IDENTIFIER
  echo "Pulling up mitm pod $MITM_CONTAINER monitoring $VM_NAME"
  /home/thomas/v-mitm-test/pod_spawn.sh $MITM_CONTAINER $VM_NAME v-mitm-test/scripts # You must be running as Thomas

  virtctl unpause vm win10vm-$IDENTIFIER
  
  if [[ ! -z $RUN_TIME ]]; then
    echo "  * Waiting for $RUN_TIME seconds"
    set -x
    sleep $RUN_TIME
    kubectl cp default/$MITM_CONTAINER:malware.pcap malware_$IDENTIFIER.pcap
    kubectl delete pod $MITM_CONTAINER
    rm ${MITM_CONTAINER}.yaml
  fi
else
  if [[ ! -z $RUN_TIME ]]; then
    sleep $RUN_TIME
  fi
  
fi

if [[ -z $RUN_TIME ]]; then
  echo " * Not shutting down, you are responsible for taking down this vm. Be sure to run 'kubectl delete -f $FILENAME' to cleanup resources"
  exit 0
fi


# Cleanup
virtctl stop win10vm-$IDENTIFIER
sleep 5
kubectl delete -f $FILENAME
rm $FILENAME