from scapy.all import *
import tldextract
import argparse
import logging

interface = 'eth0'
ETH_SRC=Ether().src

conf = {"bpf": "", "dns_whitelist_enabled": False, "dns_blacklist_enabled": False, "dns_count_enabled": False, "dns_count_allowed": 0, "dns_whitelist" : set([]), \
"tcp_count_enabled" : False, "tcp_count_allowed":0, "tcp_whitelist" : set([]), "tcp_whitelist_enabled": False, \
"tcp_blacklist" : set([]), "tcp_blacklist_enabled": False }

def get_e2LD(d):
    ext = tldextract.extract(d.decode())
    return ext.registered_domain

def nxdomain_resp(p):
    new_p = Ether(src=p[Ether].dst, dst=p[Ether].src)/\
        IP(dst=p[IP].src,src=p[IP].dst)/\
            UDP(dport=p[UDP].sport, sport=p[UDP].dport)/\
                DNS(id=p[DNS].id, qr=1, aa=1, rcode=3,qdcount=1,qd=p[DNSQR])
                    #DNSQR(qname=p[DNSQR].qname)
    return new_p

def fakeresolution_resp(p):
    new_p = Ether(src=p[Ether].dst, dst=p[Ether].src)/\
        IP(dst=p[IP].src,src=p[IP].dst)/\
            UDP(dport=p[UDP].sport, sport=p[UDP].dport)/\
                DNS(id=p[DNS].id, qr=1, aa=1, ancount=1, an=DNSRR(rrname=p[DNSQR].qname, rdata="127.0.0.1")/DNSRR(rrname=p[DNSQR].qname, rdata="127.0.0.1"), rcode=0,qdcount=1,qd=p[DNSQR])
                    # This decodes for the bazarloader sample to 127.0.0.1
                    #DNSQR(qname=p[DNSQR].qname)
    return new_p

def _dns_whitelisted(domain: str):
    # We support matching just the suffix. TODO: more sophisticated matching
    for whitelisted_dns in conf["dns_whitelist"]:
        if domain.endswith(whitelisted_dns) or whitelisted_dns.endswith(domain):
            return True
    return False

def _dns_blacklisted(domain: str):
    for blacklisted_dns in conf["dns_blacklist"]:
        if domain.endswith(blacklisted_dns) or blacklisted_dns.endswith(domain):
            return True
    return False

def dns_logic(p):
    if conf["dns_whitelist_enabled"] and _dns_whitelisted(get_e2LD(p[DNSQR].qname)):
        p[Ether].src = ETH_SRC
        p[UDP].chksum = None
        return p
    if conf["dga_fake_c2"] is not None and conf["dga_fake_c2"].encode() in p[DNSQR].qname:
        conf["dga_fake_c2_count"] += 1
        if conf["dga_fake_c2_count"] > 15:
            return fakeresolution_resp(p) # To fake the resolution of the C2

    if conf["dns_blacklist_enabled"] and _dns_blacklisted(get_e2LD(p[DNSQR].qname)):
        return nxdomain_resp(p)
    conf["dns_count_allowed"] -= 1
    if (conf["dns_count_enabled"] and conf["dns_count_allowed"] < 0):
        return nxdomain_resp(p)
    # if we want to let it through we modify the src mac address to not capture again in an infinite loop
    p[Ether].src = ETH_SRC
    p[UDP].chksum = None
    return p


def dns_intercept(p):
    if p.haslayer(DNSQR):
        p = dns_logic(p)
        _ = sendp(p,iface=interface, verbose=False)
        # print("sending ", p)
        
ESTABLISHED_CONN = {}

def get_conn_tuple(p):
    if p[TCP].sport < p[TCP].dport:
        return p[IP].src,p[TCP].sport,p[IP].dst,p[TCP].dport
    else:
        return p[IP].dst,p[TCP].dport,p[IP].src,p[TCP].sport

def is_new_tcp_conn(p):
    descriptor = get_conn_tuple(p)
    if descriptor in ESTABLISHED_CONN:
        return False
    return True

def add_new_tcp_conn(p):
    descriptor = get_conn_tuple(p)
    ESTABLISHED_CONN[descriptor] = "S"
    # print("ADDED NEW CONNECTION :", ESTABLISHED_CONN)

def reset_resp(p):
    new_p = Ether(src=p[Ether].dst, dst=p[Ether].src)/\
        IP(dst=p[IP].src,src=p[IP].dst)/\
            TCP(dport=p[TCP].sport, sport=p[TCP].dport,flags="RA",seq=0,ack=p[TCP].seq+1)
    return new_p


def let_tcp_packet_through(p):
    p[Ether].src = ETH_SRC
    p[TCP].len = None
    p[TCP].chksum = None
    return p

def tcp_logic(p):
    # case 1 : this IP is whitelisted = let packet through
    if conf["tcp_whitelist_enabled"] and (p[IP].dst in conf["tcp_whitelist"] or p[IP].src in conf["tcp_whitelist"]):
        return let_tcp_packet_through(p)
    # case 2 : this IP is blacklisted = drop packet
    if conf["tcp_blacklist_enabled"] and (p[IP].dst in conf["tcp_blacklist"] or p[IP].src in conf["tcp_blacklist"]):
        return reset_resp(p)
    # case 3 : new connection is being initiated
    if p[TCP].flags == "S":
        conf["tcp_count_allowed"] -= 1
        # check if number of connections exhausted
        if (conf["tcp_count_enabled"] and conf["tcp_count_allowed"] < 0):
            return reset_resp(p)
        else:
            # if not allow connection and add it
            add_new_tcp_conn(p)
            return let_tcp_packet_through(p)
    # case 4 : FIN flag activated
    elif p[TCP].flags & 0x01:
        descriptor = get_conn_tuple(p)
        if not is_new_tcp_conn(p):
            ESTABLISHED_CONN[descriptor] = "F"
            return let_tcp_packet_through(p)
    # not SYN or FIN .. must be normal traffic
    elif not is_new_tcp_conn(p):
        if ESTABLISHED_CONN[get_conn_tuple(p)] == 'F':
            del ESTABLISHED_CONN[get_conn_tuple(p)]
        return let_tcp_packet_through(p)
    return None

def tcp_intercept(p):
    p = tcp_logic(p)
    if p:
        try:
            _ = sendp(fragment(p, fragsize=1300),iface=interface, verbose=False)
        except OSError as e:
            print("#### Received oserror, continuing anyways, whoops", fragment(p))


def intercept(p):
    if p.haslayer(DNSQR):
        dns_intercept(p)
    elif p.haslayer(TCP):
        tcp_intercept(p)
    else:
        p[Ether].src = ETH_SRC
        if p.haslayer(UDP):
            p[UDP].chksum = None
        if p.haslayer(IP):
            p[IP].chksum = None
        _ = sendp(p,iface=interface, verbose=False)


def argument_parsing():
    parser = argparse.ArgumentParser(description='DNS and TCP MITM implementation')
    parser.add_argument('--dns_count', type=int, default=None, help="allowed number of DNS responses to go through")
    parser.add_argument('--tcp_count', type=int, default=None, help="allowed number of TCP streams to go through")
    parser.add_argument('--tcp_whitelist', type=str, help="file path with the whitelisted IPs")
    parser.add_argument('--tcp_blacklist', type=str, help="file path with the blacklisted IPs")
    parser.add_argument('--tcp_blockip', nargs="+", help="list of IPs to block")
    parser.add_argument('--dns_whitelist', type=str, help="file path with the whitelisted domains")
    parser.add_argument('--dns_blacklist', type=str, help="file path with the blacklisted domains")
    parser.add_argument('--dga_fake_c2', type=str, default=None, help="Respond with an A record after some requests.")
    requiredNamed = parser.add_argument_group('required arguments')
    requiredNamed.add_argument('--targetip', help='IP of target pod', required=True)
    args = parser.parse_args()

    if args.dns_count is not None:
        conf["dns_count_allowed"] = args.dns_count
        conf["dns_count_enabled"] = True
    if args.dns_whitelist:
        conf["dns_whitelist_enabled"] = True
        with open(args.dns_whitelist, 'r') as f:
            conf["dns_whitelist"] = set([x.rstrip().strip() for x in f if x.rstrip().strip() != ''])
    if args.dns_blacklist:
        conf["dns_blacklist_enabled"] = True
        with open(args.dns_blacklist, 'r') as f:
            conf["dns_blacklist"] = set([x.rstrip().strip() for x in f if x.rstrip().strip() != ''])

    if args.tcp_count is not None:
        conf["tcp_count_allowed"] = args.tcp_count
        conf["tcp_count_enabled"] = True
    if args.tcp_whitelist:
        conf["tcp_whitelist_enabled"] = True
        with open(args.tcp_whitelist, 'r') as f:
            conf["tcp_whitelist"] = set([x.rstrip().strip() for x in f if x.rstrip().strip() != ''])
    if args.tcp_blacklist:
        conf["tcp_blacklist_enabled"] = True
        with open(args.tcp_blacklist, 'r') as f:
            conf["tcp_blacklist"] = set([x.rstrip().strip() for x in f if x.rstrip().strip() != ''])
    if args.tcp_blockip:
        conf["tcp_blacklist_enabled"] = True
        conf["tcp_blacklist"]=conf["tcp_blacklist"].union(set(args.tcp_blockip))
    print("The args is ", args.dga_fake_c2)
    conf["dga_fake_c2"] = args.dga_fake_c2
    conf["dga_fake_c2_count"] = 0


    conf["bpf"] = f"ether host not {Ether().src} and src {args.targetip}"
    print(conf)

if __name__ == "__main__":
    argument_parsing()
    print(f"Starting capturing on interface {interface} with packet filter \"{conf['bpf']}\"")
    sniff(iface=interface, filter=conf["bpf"], store=0,  prn=intercept)
